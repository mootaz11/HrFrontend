/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { months } from './data-models/data-calendar';
import * as i0 from "@angular/core";
export class NgxSimpleCalendarService {
    constructor() {
        this.getDaysInMonth = (/**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        (month, year) => new Date(year, month + 1, 0).getDate());
        this.getFirstDayInMonth = (/**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        (month, year) => new Date(year, month, 1).getDay());
        this.getLastDayInMonth = (/**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        (month, year) => new Date(year, month, this.getDaysInMonth(month, year)).getDay());
        this.getMonthYearText = (/**
         * @param {?} monthNumber
         * @param {?} year
         * @return {?}
         */
        (monthNumber, year) => `${months.find((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.id === monthNumber)).name} ${year}`);
    }
    /**
     * @param {?} month
     * @param {?} year
     * @param {?} events
     * @return {?}
     */
    setupCalendar(month, year, events) {
        /** @type {?} */
        const firstDayInMonth = this.getFirstDayInMonth(month, year);
        /** @type {?} */
        const lastDayInMonth = this.getLastDayInMonth(month, year);
        /** @type {?} */
        const daysFromLastMonth = this.getDaysFromLastMonth(month, year, firstDayInMonth);
        /** @type {?} */
        const daysFromCurrentMonth = this.getDaysInCurrentMonth(month, year);
        /** @type {?} */
        const daysFromNextMonth = this.getDaysFromNextMonth(month, year, lastDayInMonth);
        /** @type {?} */
        const calendarData = [...daysFromLastMonth, ...daysFromCurrentMonth, ...daysFromNextMonth];
        this.markCurrentDate(calendarData);
        if (events) {
            this.addEvents(calendarData, events);
        }
        return calendarData;
    }
    /**
     * @private
     * @param {?} month
     * @param {?} year
     * @param {?} firstDayInMonth
     * @return {?}
     */
    getDaysFromLastMonth(month, year, firstDayInMonth) {
        /** @type {?} */
        let lastMonth;
        /** @type {?} */
        let activeYear;
        /** @type {?} */
        const lastMonthDays = [];
        if ((month - 1) === -1) {
            lastMonth = 11;
            activeYear = year - 1;
        }
        else {
            lastMonth = month - 1;
            activeYear = year;
        }
        /** @type {?} */
        const daysLastMonth = this.getDaysInMonth(lastMonth, activeYear);
        /** @type {?} */
        const lastFromMonth = (firstDayInMonth === 0) ? 6 : firstDayInMonth - 1;
        for (let i = (daysLastMonth - lastFromMonth) + 1; i <= daysLastMonth; i++) {
            lastMonthDays.push(this.generatedayObject(activeYear, lastMonth, i, false));
        }
        return lastMonthDays;
    }
    /**
     * @private
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    getDaysInCurrentMonth(month, year) {
        /** @type {?} */
        const daysInMonth = this.getDaysInMonth(month, year);
        /** @type {?} */
        const currentMonthDays = [];
        for (let i = 1; i <= daysInMonth; i++) {
            currentMonthDays.push(this.generatedayObject(year, month, i));
        }
        return currentMonthDays;
    }
    /**
     * @private
     * @param {?} month
     * @param {?} year
     * @param {?} lastDayInMonth
     * @return {?}
     */
    getDaysFromNextMonth(month, year, lastDayInMonth) {
        /** @type {?} */
        let nextMonth;
        /** @type {?} */
        let activeYear;
        /** @type {?} */
        const lastMonthDays = [];
        if ((month + 1) === 12) {
            nextMonth = 0;
            activeYear = year + 1;
        }
        else {
            nextMonth = month + 1;
            activeYear = year;
        }
        /** @type {?} */
        const lastFromMonth = (lastDayInMonth === 0) ? 0 : 7 - lastDayInMonth;
        for (let i = 1; i <= lastFromMonth; i++) {
            lastMonthDays.push(this.generatedayObject(activeYear, nextMonth, i, false));
        }
        return lastMonthDays;
    }
    /**
     * @private
     * @param {?} calendarData
     * @return {?}
     */
    markCurrentDate(calendarData) {
        /** @type {?} */
        const now = new Date();
        /** @type {?} */
        const todaysDate = now.getDate();
        /** @type {?} */
        const todaysMonth = now.getMonth();
        /** @type {?} */
        const todaysYear = now.getFullYear();
        calendarData.forEach((/**
         * @param {?} day
         * @return {?}
         */
        (day) => {
            if (day.number === todaysDate && day.month === todaysMonth && day.year === todaysYear) {
                day.today = true;
            }
        }));
    }
    /**
     * @private
     * @param {?} date
     * @return {?}
     */
    isWeekend(date) {
        /** @type {?} */
        const numberDay = date.getDay();
        return numberDay === 0 || numberDay === 6;
    }
    /**
     * @private
     * @param {?} dateTime
     * @return {?}
     */
    getDateTimeLastOfDay(dateTime) {
        /** @type {?} */
        const result = new Date(dateTime.getTime());
        result.setDate(result.getDate() + 1);
        result.setMilliseconds(result.getMilliseconds() - 1);
        return result;
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} day
     * @param {?=} activeMonth
     * @return {?}
     */
    generatedayObject(year, month, day, activeMonth = true) {
        /** @type {?} */
        const startDateTime = new Date(year, month, day);
        /** @type {?} */
        const endDateTime = this.getDateTimeLastOfDay(startDateTime);
        return {
            number: day,
            startDateTime,
            endDateTime,
            month: startDateTime.getMonth(),
            year: startDateTime.getFullYear(),
            weekend: this.isWeekend(startDateTime),
            today: false,
            activeMonth,
            events: []
        };
    }
    /**
     * @private
     * @param {?} calendarData
     * @param {?} events
     * @return {?}
     */
    addEvents(calendarData, events) {
        events.forEach((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (!event.endDateTime) {
                this.handleFullDayEvent(calendarData, event);
            }
            else {
                this.handleEventInterval(calendarData, event);
            }
        }));
    }
    /**
     * @private
     * @param {?} calendarData
     * @param {?} event
     * @return {?}
     */
    handleFullDayEvent(calendarData, event) {
        try {
            /** @type {?} */
            const dayWithEvent = calendarData.find((/**
             * @param {?} day
             * @return {?}
             */
            (day) => {
                return day.startDateTime.getTime() <= event.startDateTime.getTime() && day.endDateTime.getTime() >= event.startDateTime.getTime();
            }));
            dayWithEvent.events.push(event);
        }
        catch (e) {
            console.log('startDateTime on event is not set');
        }
    }
    /**
     * @private
     * @param {?} calendarData
     * @param {?} event
     * @return {?}
     */
    handleEventInterval(calendarData, event) {
        try {
            /** @type {?} */
            const fromDaysInCalendar = calendarData.filter((/**
             * @param {?} day
             * @return {?}
             */
            (day) => day.endDateTime.getTime() >= event.startDateTime.getTime()));
            /** @type {?} */
            const intervalDaysInCalendar = fromDaysInCalendar.filter((/**
             * @param {?} day
             * @return {?}
             */
            (day) => {
                /** @type {?} */
                const yesterDayReferentDay = new Date(day.endDateTime.getTime());
                yesterDayReferentDay.setDate(yesterDayReferentDay.getDate() - 1);
                return yesterDayReferentDay.getTime() <= event.endDateTime.getTime();
            }));
            intervalDaysInCalendar.forEach((/**
             * @param {?} day
             * @return {?}
             */
            (day) => {
                day.events.push(event);
            }));
        }
        catch (e) {
            console.log('Error on handling event interval');
        }
    }
}
NgxSimpleCalendarService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgxSimpleCalendarService.ctorParameters = () => [];
/** @nocollapse */ NgxSimpleCalendarService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function NgxSimpleCalendarService_Factory() { return new NgxSimpleCalendarService(); }, token: NgxSimpleCalendarService, providedIn: "root" });
if (false) {
    /** @type {?} */
    NgxSimpleCalendarService.prototype.getDaysInMonth;
    /** @type {?} */
    NgxSimpleCalendarService.prototype.getFirstDayInMonth;
    /** @type {?} */
    NgxSimpleCalendarService.prototype.getLastDayInMonth;
    /** @type {?} */
    NgxSimpleCalendarService.prototype.getMonthYearText;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LXNpbXBsZS1jYWxlbmRhci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNpbXBsZS1jYWxlbmRhci8iLCJzb3VyY2VzIjpbImxpYi9uZ3gtc2ltcGxlLWNhbGVuZGFyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUE2QixNQUFNLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQzs7QUFLL0UsTUFBTSxPQUFPLHdCQUF3QjtJQUVuQztRQUdBLG1CQUFjOzs7OztRQUFHLENBQUMsS0FBYSxFQUFFLElBQVksRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUM7UUFFekYsdUJBQWtCOzs7OztRQUFHLENBQUMsS0FBYSxFQUFFLElBQVksRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBQztRQUV4RixzQkFBaUI7Ozs7O1FBQUcsQ0FBQyxLQUFhLEVBQUUsSUFBWSxFQUFFLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUM7UUFxQnRILHFCQUFnQjs7Ozs7UUFBRyxDQUFDLFdBQW1CLEVBQUUsSUFBWSxFQUFFLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJOzs7O1FBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssV0FBVyxFQUFDLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRSxFQUFDO0lBM0IzSCxDQUFDOzs7Ozs7O0lBUUQsYUFBYSxDQUFDLEtB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RixzQkFBc0IsQ0FBQyxPQUFPOzs7O1lBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDckMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDekIsQ0FBQyxFQUFDLENBQUM7U0FDSjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1NBQ2pEO0lBQ0gsQ0FBQzs7O1lBcEtGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7Ozs7OztJQU1DLGtEQUF5Rjs7SUFFekYsc0RBQXdGOztJQUV4RixxREFBc0g7O0lBcUJ0SCxvREFBMkgiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NhbGVuZGFyRGF5LCBDYWxlbmRhckV2ZW50LCBtb250aHN9IGZyb20gJy4vZGF0YS1tb2RlbHMvZGF0YS1jYWxlbmRhcic7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5neFNpbXBsZUNhbGVuZGFyU2VydmljZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cblxuICBnZXREYXlzSW5Nb250aCA9IChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpID0+IG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgMCkuZ2V0RGF0ZSgpO1xuXG4gIGdldEZpcnN0RGF5SW5Nb250aCA9IChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpID0+IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKTtcblxuICBnZXRMYXN0RGF5SW5Nb250aCA9IChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpID0+IG5ldyBEYXRlKHllYXIsIG1vbnRoLCB0aGlzLmdldERheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKSkuZ2V0RGF5KCk7XG5cbiAgc2V0dXBDYWxlbmRhcihtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIsIGV2ZW50czogQ2FsZW5kYXJFdmVudFtdKTogQ2FsZW5kYXJEYXlbXSB7XG4gICAgY29uc3QgZmlyc3REYXlJbk1vbnRoID0gdGhpcy5nZXRGaXJzdERheUluTW9udGgobW9udGgsIHllYXIpO1xuICAgIGNvbnN0IGxhc3REYXlJbk1vbnRoID0gdGhpcy5nZXRMYXN0RGF5SW5Nb250aChtb250aCwgeWVhcik7XG5cbiAgICBjb25zdCBkYXlzRnJvbUxhc3RNb250aCA9IHRoaXMuZ2V0RGF5c0Zyb21MYXN0TW9udGgobW9udGgsIHllYXIsIGZpcnN0RGF5SW5Nb250aCk7XG4gICAgY29uc3QgZGF5c0Zyb21DdXJyZW50TW9udGggPSB0aGlzLmdldERheXNJbkN1cnJlbnRNb250aChtb250aCwgeWVhcik7XG4gICAgY29uc3QgZGF5c0Zyb21OZXh0TW9udGggPSB0aGlzLmdldERheXNGcm9tTmV4dE1vbnRoKG1vbnRoLCB5ZWFyLCBsYXN0RGF5SW5Nb250aCk7XG5cbiAgICBjb25zdCBjYWxlbmRhckRhdGEgPSBbLi4uZGF5c0Zyb21MYXN0TW9udGgsIC4uLmRheXNGcm9tQ3VycmVudE1vbnRoLCAuLi5kYXlzRnJvbU5leHRNb250aF07XG5cbiAgICB0aGlzLm1hcmtDdXJyZW50RGF0ZShjYWxlbmRhckRhdGEpO1xuXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdGhpcy5hZGRFdmVudHMoY2FsZW5kYXJEYXRhLCBldmVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxlbmRhckRhdGE7XG4gIH1cblxuICBnZXRNb250aFllYXJUZXh0ID0gKG1vbnRoTnVtYmVyOiBudW1iZXIsIHllYXI6IG51bWJlcikgPT4gYCR7bW9udGhzLmZpbmQoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IG1vbnRoTnVtYmVyKS5uYW1lfSAke3llYXJ9YDtcblxuICBwcml2YXRlIGdldERheXNGcm9tTGFzdE1vbnRoKG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlciwgZmlyc3REYXlJbk1vbnRoOiBudW1iZXIpOiBDYWxlbmRhckRheVtdIHtcbiAgICBsZXQgbGFzdE1vbnRoLCBhY3RpdmVZZWFyO1xuICAgIGNvbnN0IGxhc3RNb250aERheXMgPSBbXTtcbiAgICBpZiAoKG1vbnRoIC0gMSkgPT09IC0xKSB7XG4gICAgICBsYXN0TW9udGggPSAxMTtcbiAgICAgIGFjdGl2ZVllYXIgPSB5ZWFyIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE1vbnRoID0gbW9udGggLSAxO1xuICAgICAgYWN0aXZlWWVhciA9IHllYXI7XG4gICAgfVxuXG4gICAgY29uc3QgZGF5c0xhc3RNb250aCA9IHRoaXMuZ2V0RGF5c0luTW9udGgobGFzdE1vbnRoLCBhY3RpdmVZZWFyKTtcbiAgICBjb25zdCBsYXN0RnJvbU1vbnRoID0gKGZpcnN0RGF5SW5Nb250aCA9PT0gMCkgPyA2IDogZmlyc3REYXlJbk1vbnRoIC0gMTtcblxuICAgIGZvciAobGV0IGkgPSAoZGF5c0xhc3RNb250aCAtIGxhc3RGcm9tTW9udGgpICsgMTsgaSA8PSBkYXlzTGFzdE1vbnRoOyBpKyspIHtcbiAgICAgIGxhc3RNb250aERheXMucHVzaCh0aGlzLmdlbmVyYXRlZGF5T2JqZWN0KGFjdGl2ZVllYXIsIGxhc3RNb250aCwgaSwgZmFsc2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdE1vbnRoRGF5cztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGF5c0luQ3VycmVudE1vbnRoKG1vbnRoLCB5ZWFyKTogQ2FsZW5kYXJEYXlbXSB7XG4gICAgY29uc3QgZGF5c0luTW9udGggPSB0aGlzLmdldERheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKTtcbiAgICBjb25zdCBjdXJyZW50TW9udGhEYXlzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBkYXlzSW5Nb250aDsgaSsrKSB7XG4gICAgICBjdXJyZW50TW9udGhEYXlzLnB1c2godGhpcy5nZW5lcmF0ZWRheU9iamVjdCh5ZWFyLCBtb250aCwgaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50TW9udGhEYXlzO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREYXlzRnJvbU5leHRNb250aChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIsIGxhc3REYXlJbk1vbnRoOiBudW1iZXIpOiBDYWxlbmRhckRheVtdIHtcbiAgICBsZXQgbmV4dE1vbnRoLCBhY3RpdmVZZWFyO1xuXG4gICAgY29uc3QgbGFzdE1vbnRoRGF5cyA9IFtdO1xuICAgIGlmICgobW9udGggKyAxKSA9PT0gMTIpIHtcbiAgICAgIG5leHRNb250aCA9IDA7XG4gICAgICBhY3RpdmVZZWFyID0geWVhciArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRNb250aCA9IG1vbnRoICsgMTtcbiAgICAgIGFjdGl2ZVllYXIgPSB5ZWFyO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RGcm9tTW9udGggPSAobGFzdERheUluTW9udGggPT09IDApID8gMCA6IDcgLSBsYXN0RGF5SW5Nb250aDtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxhc3RGcm9tTW9udGg7IGkrKykge1xuICAgICAgbGFzdE1vbnRoRGF5cy5wdXNoKHRoaXMuZ2VuZXJhdGVkYXlPYmplY3QoYWN0aXZlWWVhciwgbmV4dE1vbnRoLCBpLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0TW9udGhEYXlzO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrQ3VycmVudERhdGUoY2FsZW5kYXJEYXRhOiBDYWxlbmRhckRheVtdKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCB0b2RheXNEYXRlID0gbm93LmdldERhdGUoKTtcbiAgICBjb25zdCB0b2RheXNNb250aCA9IG5vdy5nZXRNb250aCgpO1xuICAgIGNvbnN0IHRvZGF5c1llYXIgPSBub3cuZ2V0RnVsbFllYXIoKTtcblxuICAgIGNhbGVuZGFyRGF0YS5mb3JFYWNoKChkYXkpID0+IHtcbiAgICAgIGlmIChkYXkubnVtYmVyID09PSB0b2RheXNEYXRlICYmIGRheS5tb250aCA9PT0gdG9kYXlzTW9udGggJiYgZGF5LnllYXIgPT09IHRvZGF5c1llYXIpIHtcbiAgICAgICAgZGF5LnRvZGF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaXNXZWVrZW5kKGRhdGU6IERhdGUpIHtcbiAgICBjb25zdCBudW1iZXJEYXkgPSBkYXRlLmdldERheSgpO1xuICAgIHJldHVybiBudW1iZXJEYXkgPT09IDAgfHwgbnVtYmVyRGF5ID09PSA2O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREYXRlVGltZUxhc3RPZkRheShkYXRlVGltZTogRGF0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKGRhdGVUaW1lLmdldFRpbWUoKSk7XG4gICAgcmVzdWx0LnNldERhdGUocmVzdWx0LmdldERhdGUoKSArIDEpO1xuICAgIHJlc3VsdC5zZXRNaWxsaXNlY29uZHMocmVzdWx0LmdldE1pbGxpc2Vjb25kcygpIC0gMSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGdlbmVyYXRlZGF5T2JqZWN0KHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIsIGFjdGl2ZU1vbnRoOiBib29sZWFuID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN0YXJ0RGF0ZVRpbWUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcbiAgICBjb25zdCBlbmREYXRlVGltZSA9IHRoaXMuZ2V0RGF0ZVRpbWVMYXN0T2ZEYXkoc3RhcnREYXRlVGltZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlcjogZGF5LFxuICAgICAgc3RhcnREYXRlVGltZSxcbiAgICAgIGVuZERhdGVUaW1lLFxuICAgICAgbW9udGg6IHN0YXJ0RGF0ZVRpbWUuZ2V0TW9udGgoKSxcbiAgICAgIHllYXI6IHN0YXJ0RGF0ZVRpbWUuZ2V0RnVsbFllYXIoKSxcbiAgICAgIHdlZWtlbmQ6IHRoaXMuaXNXZWVrZW5kKHN0YXJ0RGF0ZVRpbWUpLFxuICAgICAgdG9kYXk6IGZhbHNlLFxuICAgICAgYWN0aXZlTW9udGgsXG4gICAgICBldmVudHM6IFtdXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkRXZlbnRzKGNhbGVuZGFyRGF0YTogQ2FsZW5kYXJEYXlbXSwgZXZlbnRzOiBDYWxlbmRhckV2ZW50W10pIHtcbiAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQ6IENhbGVuZGFyRXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQuZW5kRGF0ZVRpbWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGdWxsRGF5RXZlbnQoY2FsZW5kYXJEYXRhLCBldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50SW50ZXJ2YWwoY2FsZW5kYXJEYXRhLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUZ1bGxEYXlFdmVudChjYWxlbmRhckRhdGE6IENhbGVuZGFyRGF5W10sIGV2ZW50OiBDYWxlbmRhckV2ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRheVdpdGhFdmVudCA9IGNhbGVuZGFyRGF0YS5maW5kKChkYXkpID0+IHtcbiAgICAgICAgcmV0dXJuIGRheS5zdGFydERhdGVUaW1lLmdldFRpbWUoKSA8PSBldmVudC5zdGFydERhdGVUaW1lLmdldFRpbWUoKSAmJiBkYXkuZW5kRGF0ZVRpbWUuZ2V0VGltZSgpID49IGV2ZW50LnN0YXJ0RGF0ZVRpbWUuZ2V0VGltZSgpO1xuICAgICAgfSk7XG4gICAgICBkYXlXaXRoRXZlbnQuZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdzdGFydERhdGVUaW1lIG9uIGV2ZW50IGlzIG5vdCBzZXQnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUV2ZW50SW50ZXJ2YWwoY2FsZW5kYXJEYXRhOiBDYWxlbmRhckRheVtdLCBldmVudDogQ2FsZW5kYXJFdmVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmcm9tRGF5c0luQ2FsZW5kYXIgPSBjYWxlbmRhckRhdGEuZmlsdGVyKChkYXkpID0+IGRheS5lbmREYXRlVGltZS5nZXRUaW1lKCkgPj0gZXZlbnQuc3RhcnREYXRlVGltZS5nZXRUaW1lKCkpO1xuICAgICAgY29uc3QgaW50ZXJ2YWxEYXlzSW5DYWxlbmRhciA9IGZyb21EYXlzSW5DYWxlbmRhci5maWx0ZXIoKGRheSkgPT4ge1xuICAgICAgICBjb25zdCB5ZXN0ZXJEYXlSZWZlcmVudERheSA9IG5ldyBEYXRlKGRheS5lbmREYXRlVGltZS5nZXRUaW1lKCkpO1xuICAgICAgICB5ZXN0ZXJEYXlSZWZlcmVudERheS5zZXREYXRlKHllc3RlckRheVJlZmVyZW50RGF5LmdldERhdGUoKSAtIDEpO1xuICAgICAgICByZXR1cm4geWVzdGVyRGF5UmVmZXJlbnREYXkuZ2V0VGltZSgpIDw9IGV2ZW50LmVuZERhdGVUaW1lLmdldFRpbWUoKTtcbiAgICAgIH0pO1xuICAgICAgaW50ZXJ2YWxEYXlzSW5DYWxlbmRhci5mb3JFYWNoKChkYXkpID0+IHtcbiAgICAgICAgZGF5LmV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvbiBoYW5kbGluZyBldmVudCBpbnRlcnZhbCcpO1xuICAgIH1cbiAgfVxufVxuIl19