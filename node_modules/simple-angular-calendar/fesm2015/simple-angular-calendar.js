import { Directive, Component, EventEmitter, forwardRef, Input, Output, ContentChild, TemplateRef, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';
import { BrowserModule } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Names of the days of the week in English.
  @type {?} */
const DAY_NAMES = [
    'Sunday',
    'Monday',
    'Tuesday',
    'Wednesday',
    'Thursday',
    'Friday',
    'Saturday'
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const DayOfWeek = {
    Sunday: 0,
    Monday: 1,
    Tuesday: 2,
    Wednesday: 3,
    Thursday: 4,
    Friday: 5,
    Saturday: 6,
};
DayOfWeek[DayOfWeek.Sunday] = 'Sunday';
DayOfWeek[DayOfWeek.Monday] = 'Monday';
DayOfWeek[DayOfWeek.Tuesday] = 'Tuesday';
DayOfWeek[DayOfWeek.Wednesday] = 'Wednesday';
DayOfWeek[DayOfWeek.Thursday] = 'Thursday';
DayOfWeek[DayOfWeek.Friday] = 'Friday';
DayOfWeek[DayOfWeek.Saturday] = 'Saturday';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Contains several functions to work with
 * dates in JS.
 */
class DateMath {
    constructor() { }
    /**
     * Adds days to the specified date.
     * @param {?} date Date that will be increased.
     * @param {?} days Number of days to add to the specified
     * date.
     * @return {?}
     */
    static addDays(date, days) {
        /** @type {?} */
        const daysAdded = new Date(date.valueOf());
        daysAdded.setDate(daysAdded.getDate() + days);
        return daysAdded;
    }
    /**
     * Substract days to the specified date.
     * @param {?} date Date that will be decreased.
     * @param {?} days Number of days to substract from
     * the specified date.
     * @return {?}
     */
    static substractDays(date, days) {
        return DateMath.addDays(date, -days);
    }
    /**
     * Adds a number of months to the specified date.
     * @param {?} date Date that will be increased.
     * @param {?} months Months to add.
     * @return {?}
     */
    static addMonths(date, months) {
        /** @type {?} */
        const monthsAdded = new Date(date.valueOf());
        monthsAdded.setMonth(date.getMonth() + months);
        return monthsAdded;
    }
    /**
     * Substracts a number of months from the specified date.
     * @param {?} date Date that will be decreased.
     * @param {?} months Months to substract.
     * @return {?}
     */
    static substractMonths(date, months) {
        /** @type {?} */
        const monthsSubstracted = new Date(date.valueOf());
        monthsSubstracted.setMonth(date.getMonth() - months);
        return monthsSubstracted;
    }
    /**
     * Gets the date corresponding to the first day
     * of the month of the specified date.
     * @param {?} date Date.
     * @return {?}
     */
    static getFirstDayOfMonth(date) {
        /** @type {?} */
        const firstDay = new Date();
        firstDay.setFullYear(date.getFullYear(), date.getMonth(), 1);
        return firstDay;
    }
    /**
     * Gets the date corresponding to the last day
     * of the month of the specified date.
     * @param {?} date Date.
     * @return {?}
     */
    static getLastDayOfMonth(date) {
        /** @type {?} */
        const lastDay = new Date();
        lastDay.setFullYear(date.getFullYear(), date.getMonth() + 1, 0);
        return lastDay;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Creates a view of a month.
 */
class MonthView {
    /**
     * Creates a new instance of MonthView.
     * @param {?} date Date of the month.
     */
    constructor(date) {
        this.date = date;
        this.WEEKS_PER_MONTH = 5;
        this.DAYS_PER_WEEK = 7;
    }
    /**
     * Creates the grid corresponding to the month specified
     * by the date.
     * @param {?=} completeHoles Indicates if the beginning and end
     * of the grid should be completed with the days of the
     * adjacent months.
     * @param {?=} weekStart Day of week to be considered the beginning
     * of the week.
     * @return {?}
     */
    createView(completeHoles = false, weekStart = DayOfWeek.Monday) {
        /** @type {?} */
        const currentMonthGrid = this.createGrid(this.date, weekStart);
        if (completeHoles) {
            /** @type {?} */
            const needsToBeFilledFromBeginning = !!!currentMonthGrid[0][0];
            if (needsToBeFilledFromBeginning) {
                /** @type {?} */
                const lastMonth = DateMath.substractMonths(this.date, 1);
                /** @type {?} */
                const lastDayOfLastMonth = DateMath.getLastDayOfMonth(lastMonth).getDate();
                /** @type {?} */
                const firstDayOfCurrentMonth = DateMath.getFirstDayOfMonth(this.date);
                /** @type {?} */
                const daysToPickFromLastMonth = firstDayOfCurrentMonth.getDay() - weekStart.valueOf();
                for (let i = 0; i < daysToPickFromLastMonth; i++) {
                    /** @type {?} */
                    const currentDayOfMonth = lastDayOfLastMonth - (daysToPickFromLastMonth - (i + 1));
                    /** @type {?} */
                    const currentDate = new Date(lastMonth.getFullYear(), lastMonth.getMonth(), currentDayOfMonth);
                    currentMonthGrid[0][i] = {
                        isToday: false,
                        isSelected: false,
                        day: currentDayOfMonth,
                        date: currentDate
                    };
                }
            }
            /** @type {?} */
            let fillingDays = 1;
            for (let week = 0; week < this.WEEKS_PER_MONTH; week++) {
                for (let dayOfWeek = 0; dayOfWeek < this.DAYS_PER_WEEK; dayOfWeek++) {
                    if (!!!currentMonthGrid[week][dayOfWeek]) {
                        /** @type {?} */
                        const fillingDates = new Date(this.date.getFullYear(), this.date.getMonth(), fillingDays++);
                        currentMonthGrid[week][dayOfWeek] = {
                            isToday: false,
                            isSelected: false,
                            day: fillingDays,
                            date: fillingDates
                        };
                    }
                }
            }
        }
        return currentMonthGrid;
    }
    /**
     * Creates the grid corresponding to the month specified
     * by the date.
     * @param {?} date Date to use.
     * @param {?=} weekStart Day of week which will be considered
     * the beginning of the week.
     * @return {?}
     */
    createGrid(date, weekStart = DayOfWeek.Monday) {
        /** @type {?} */
        const grid = this.initGrid();
        /** @type {?} */
        const firstDayOfWeek = DateMath.getFirstDayOfMonth(date).getDay() - weekStart.valueOf();
        /** @type {?} */
        const lastDay = DateMath.getLastDayOfMonth(date).getDate();
        /** @type {?} */
        const today = new Date();
        /** @type {?} */
        let dayOfWeek = firstDayOfWeek;
        /** @type {?} */
        let currentDayOfMonth = 1;
        for (let week = 0; week < this.WEEKS_PER_MONTH; week++) {
            for (; dayOfWeek < this.DAYS_PER_WEEK && currentDayOfMonth <= lastDay; dayOfWeek++) {
                /** @type {?} */
                const todaySameYear = today.getFullYear() === this.date.getFullYear();
                /** @type {?} */
                const todaySameMonth = today.getMonth() === this.date.getMonth();
                /** @type {?} */
                const todaySameDay = today.getDate() === currentDayOfMonth;
                /** @type {?} */
                const currentDate = new Date(this.date.getFullYear(), this.date.getMonth(), currentDayOfMonth);
                grid[week][dayOfWeek] = {
                    isToday: todaySameYear && todaySameMonth && todaySameDay,
                    isSelected: this.date.getDate() === currentDayOfMonth,
                    day: currentDayOfMonth,
                    date: currentDate
                };
                currentDayOfMonth++;
            }
            dayOfWeek = 0;
        }
        return grid;
    }
    /**
     * Initializes the grid that contains
     * the info about the "shape" of the
     * month.
     * @return {?}
     */
    initGrid() {
        /** @type {?} */
        const defaultEmpty = undefined;
        /** @type {?} */
        const grid = [
            new Array(this.DAYS_PER_WEEK).fill(defaultEmpty),
            new Array(this.DAYS_PER_WEEK).fill(defaultEmpty),
            new Array(this.DAYS_PER_WEEK).fill(defaultEmpty),
            new Array(this.DAYS_PER_WEEK).fill(defaultEmpty),
            new Array(this.DAYS_PER_WEEK).fill(defaultEmpty)
        ];
        return grid;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Directive to select the template to use
 * for the day cell.
 */
class DayTemplateDirective {
    constructor() { }
}
DayTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[scDayTemplate]'
            },] },
];
/** @nocollapse */
DayTemplateDirective.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DayOfWeekCaptionTemplateDirective {
    constructor() { }
}
DayOfWeekCaptionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[scDayOfWeekCaptionTemplate]'
            },] },
];
/** @nocollapse */
DayOfWeekCaptionTemplateDirective.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class MonthCaptionTemplateDirective {
    constructor() { }
}
MonthCaptionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[scMonthCaptionTemplate]'
            },] },
];
/** @nocollapse */
MonthCaptionTemplateDirective.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Default formatter for the captions of the days
 * of the week.
 * @param {?} firstDayOfWeek
 * @return {?}
 */
function defaultDayOfWeekCaptionFormatterFactory(firstDayOfWeek) {
    return (dayOfWeek) => {
        /** @type {?} */
        const formattedDayNames = DAY_NAMES.map(dayName => formatDayName(dayName));
        /** @type {?} */
        const reordered = reorderDays(formattedDayNames, firstDayOfWeek);
        return reordered[dayOfWeek.valueOf()];
    };
}
/**
 * Applies formatting to the name of the day.
 * @param {?} dayName Name of the day.
 * @return {?}
 */
function formatDayName(dayName) {
    /** @type {?} */
    const newDayName = dayName.substr(0, 1).toUpperCase() + dayName.substr(1, 1).toLowerCase();
    return newDayName;
}
/**
 * Reorders the array of names so the first index
 * corresponds with the name of the first day of
 * the week.
 * @param {?} dayNames Array with the names of the days
 * of the week.
 * @param {?} firstDayOfWeek First day of the week.
 * @return {?}
 */
function reorderDays(dayNames, firstDayOfWeek) {
    /** @type {?} */
    const dayCount = DAY_NAMES.length;
    /** @type {?} */
    const dayIndex = firstDayOfWeek.valueOf();
    /** @type {?} */
    const reordered = (new Array(dayCount)).fill(0);
    for (let i = 0; i < dayCount; i++) {
        /** @type {?} */
        const newPosition = (i + dayIndex) % dayCount;
        reordered[i] = dayNames[newPosition];
    }
    return reordered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Month calendar provider.
  @type {?} */
const MONTH_CALENDAR_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MonthCalendarComponent),
    multi: true
};
/**
 * Control that represents a calendar.
 */
class MonthCalendarComponent {
    constructor() {
        /**
         * Event raised when the user selects a date.
         */
        this.change = new EventEmitter();
        /**
         * Event raised when the user clicks the calendar.
         */
        this.monthClick = new EventEmitter();
        /**
         * Sets if the control should be in a
         * disabled state.
         */
        this.disabled = false;
        /**
         * Date to show.
         */
        this._value = new Date();
        /**
         * Specifies how a day cell should grow.
         */
        this._grow = { mode: 'stretch' };
        this.defaultFirstDayOfWeek = DayOfWeek.Sunday;
        this.defaultDayOfWeekCaptionFormatter = defaultDayOfWeekCaptionFormatterFactory(this.defaultFirstDayOfWeek);
        /**
         * First day of the week.
         */
        this._firstDayOfWeek = this.defaultFirstDayOfWeek;
        /**
         * CSS class for the month.
         */
        this.monthClass = 'sc-month';
        /**
         * CSS class for the disabled state.
         */
        this.disabledClass = 'sc-month--disabled';
        /**
         * CSS class for the month caption.
         */
        this.monthCaptionClass = 'sc-month__caption';
        /**
         * CSS class for the day of the week captions.
         */
        this.dayOfWeekCaptionClass = 'sc-month__week-caption';
        /**
         * CSS class for the day captions.
         */
        this.dayCaptionClass = 'sc-month__day';
        /**
         * CSS class for the current day.
         */
        this.currentDayClass = 'sc-month__day--today';
        /**
         * CSS class for the day when the state is disabled.
         */
        this.disabledDayClass = 'sc-month__day--disabled';
        /**
         * CSS class for the selected day.
         */
        this.selectedDayClass = 'sc-month__day--selected';
        this.defaultMonthCaptionFormatter = (date) => date.toDateString();
        this.defaultDayFormatter = (day) => day ? day.day.toString() : '';
        this.onChange = (date) => { };
        this.onTouched = () => { };
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    set value(date) {
        this.writeValue(date);
    }
    /**
     * @param {?} mode
     * @return {?}
     */
    set grow(mode) {
        if (mode) {
            this._grow = mode;
        }
        else {
            this._grow = { mode: 'stretch' };
        }
    }
    /**
     * @return {?}
     */
    get grow() {
        return this._grow;
    }
    /**
     * @param {?} dayOfWeek
     * @return {?}
     */
    set firstDayOfWeek(dayOfWeek) {
        this._firstDayOfWeek = dayOfWeek;
        this.defaultDayOfWeekCaptionFormatter = defaultDayOfWeekCaptionFormatterFactory(this._firstDayOfWeek);
        this.refresh();
    }
    /**
     * @return {?}
     */
    get firstDayOfWeek() {
        return this._firstDayOfWeek;
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set dayFormatter(formatter) {
        this._dayFormatter = formatter;
        this.refresh();
    }
    /**
     * @return {?}
     */
    get dayFormatter() {
        return this._dayFormatter;
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set dayOfWeekCaptionFormatter(formatter) {
        this._dayOfWeekCaptionFormatter = formatter;
        this.refresh();
    }
    /**
     * @return {?}
     */
    get dayOfWeekCaptionFormatter() {
        return this._dayOfWeekCaptionFormatter;
    }
    /**
     * @param {?} formatter
     * @return {?}
     */
    set monthCaptionFormatter(formatter) {
        this._monthCaptionFormatter = formatter;
        this.refresh();
    }
    /**
     * @return {?}
     */
    get monthCaptionFormatter() {
        return this._monthCaptionFormatter;
    }
    /**
     * Initializes the component.
     * @return {?}
     */
    ngOnInit() {
        this.refresh();
    }
    /**
     * @param {?} date
     * @return {?}
     */
    writeValue(date) {
        if (date) {
            this._value = date;
            this.refresh();
            this.onChange(date);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Refreshes the component.
     * @return {?}
     */
    refresh() {
        this.refreshMonthCaption(this.value);
        this.refreshDayOfWeekCaptions();
        this.refreshView(this.value);
    }
    /**
     * Refreshes the month caption.
     * @param {?} date Date.
     * @return {?}
     */
    refreshMonthCaption(date) {
        if (this.monthCaptionFormatter) {
            this.monthCaption = this.monthCaptionFormatter(date);
        }
        else {
            this.monthCaption = this.defaultMonthCaptionFormatter(date);
        }
    }
    /**
     * Refreshes the day of week captions.
     * @return {?}
     */
    refreshDayOfWeekCaptions() {
        /** @type {?} */
        const dayCaptions = [];
        /** @type {?} */
        const dayOfWeekFormatter = this.dayOfWeekCaptionFormatter ?
            this.dayOfWeekCaptionFormatter :
            this.defaultDayOfWeekCaptionFormatter;
        for (let i = 0; i < DAY_NAMES.length; i++) {
            dayCaptions.push(dayOfWeekFormatter(i));
        }
        this.daysOfWeekCaptions = dayCaptions;
    }
    /**
     * Refreshes the calendar view.
     * @param {?} date Date.
     * @return {?}
     */
    refreshView(date) {
        this.view = new MonthView(date).createView(false, this.firstDayOfWeek);
    }
    /**
     * Gets the CSS classes to apply to the month.
     * @return {?}
     */
    getClassForMonth() {
        /** @type {?} */
        let classesToApply = this.monthClass;
        if (this.disabled) {
            classesToApply = this.monthClass + ' ' + this.disabledClass;
        }
        return classesToApply;
    }
    /**
     * Gets the CSS class applicable to
     * the specified day.
     * @param {?=} day Day.
     * @return {?}
     */
    getClassForDay(day) {
        /** @type {?} */
        let dayClassToApply = '';
        if (day) {
            if (day.day === this.value.getDate()) {
                dayClassToApply = this.selectedDayClass;
            }
            else if (day.isToday) {
                dayClassToApply = this.currentDayClass;
            }
            else if (this.customDayClass) {
                /** @type {?} */
                const date = new Date(this.value.valueOf());
                date.setDate(day.day);
                dayClassToApply = this.customDayClass(day);
            }
            if (this.disabled) {
                dayClassToApply = dayClassToApply + ' ' + this.disabledDayClass;
            }
            return this.dayCaptionClass + ' ' + dayClassToApply;
        }
        else {
            return this.dayCaptionClass;
        }
    }
    /**
     * Gets a formatted string corresponding
     * to the specified day.
     * @param {?} day Day to format.
     * @return {?}
     */
    getFormattedDay(day) {
        if (this.dayFormatter) {
            return this.dayFormatter(day);
        }
        else {
            return this.defaultDayFormatter(day);
        }
    }
    /**
     * Controls the click event of a day cell.
     * @param {?} dayInfo Info about the selected day.
     * @return {?}
     */
    onDayClick(dayInfo) {
        if (!this.disabled && dayInfo) {
            /** @type {?} */
            const selectedDate = new Date(this.value.valueOf());
            selectedDate.setDate(dayInfo.day);
            this.value = new Date(selectedDate.valueOf());
            this.change.emit(selectedDate);
        }
    }
    /**
     * Controls the click event of the month.
     * @return {?}
     */
    onMonthClick() {
        if (!this.disabled) {
            this.monthClick.emit(this);
        }
    }
}
MonthCalendarComponent.decorators = [
    { type: Component, args: [{
                selector: 'sc-month-calendar',
                template: `<!-- Month -->
<div (click)="onMonthClick()"
     [ngClass]="['column', grow.mode == 'stretch' ? 'stretch-vertically' : '', getClassForMonth()]">

  <!-- Month caption -->
  <div class="row">

    <!-- Month caption cell -->
    <div class="w-100"
         [class.label]="grow.mode != 'mixed'"
         [class.ratio-height]="grow.mode == 'proportional'"
         [class.stretch-horizontally]="grow.mode == 'stretch' || grow.mode == 'mixed'">

      <!-- Month caption cell content -->
      <div [class.label__content]="grow.mode != 'mixed'">

        <ng-container *ngTemplateOutlet="monthTemplate ? monthTemplate : defaultMonthTemplate; context: { $implicit: value }"></ng-container>

      </div>
    </div>
  </div>

  <!-- Week captions -->
  <div class="row">

    <!-- Week captions cell -->
    <div [class.label]="grow.mode != 'mixed'"
         [class.ratio-square]="grow.mode == 'proportional'"
         [class.stretch-horizontally]="grow.mode == 'stretch' || grow.mode == 'mixed'"
         *ngFor="let dayOfWeekCaption of daysOfWeekCaptions; let i = index">

      <!-- Week caption cell content -->
      <div [class.label__content]="grow.mode != 'mixed'">

        <ng-container *ngTemplateOutlet="dayOfWeekTemplate ? dayOfWeekTemplate : defaultDayOfWeekTemplate; context: { $implicit: dayOfWeekCaption, dayOfWeekIndex: i }"></ng-container>

      </div>
    </div>
  </div>

  <!-- Days -->
  <div class="row"
       *ngFor="let week of view">

    <!-- Day cell -->
    <div (click)="onDayClick(day)"
         class="ratio-square label"
         [class.ratio-square]="grow.mode == 'proportional' || grow.mode == 'mixed'"
         [class.stretch-horizontally]="grow.mode == 'stretch'"
         *ngFor="let day of week">

      <!-- Day content -->
      <div class="label__content">

        <ng-container *ngTemplateOutlet="dayTemplate ? dayTemplate : defaultDayTemplate; context: { $implicit: day }"></ng-container>

      </div>

    </div>

  </div>

</div>



<!-- Templates -->

<!-- Day template -->
<ng-template #defaultDayTemplate
             let-day>
  <div class="flex-expanded-container">
    <div [ngClass]="['flex-expand', getClassForDay(day)]">{{ getFormattedDay(day) }}</div>
  </div>
</ng-template>

<!-- Day of week cells template -->
<ng-template #defaultDayOfWeekTemplate
             let-dayOfWeek
             let-dayOfWeekIndex="dayOfWeekIndex">
  <div [class.flex-expanded-container]="grow.mode != 'mixed'">
    <div [ngClass]="['flex-expand', 'flex-centered', dayOfWeekCaptionClass]">
      {{ dayOfWeek }}
    </div>
  </div>
</ng-template>

<!-- Month cell template -->
<ng-template #defaultMonthTemplate
             let-date>
  <div [class.flex-expanded-container]="grow.mode != 'mixed'">
    <div [ngClass]="['flex-expand', 'flex-centered', monthCaptionClass]">
      {{ monthCaption }}
    </div>
  </div>
</ng-template>
`,
                styles: [`.column{display:flex;flex-flow:column;flex:1}.row{display:flex;flex:1}.label{position:relative}.label__content{position:absolute;top:0;left:0;bottom:0;right:0}.flex-expanded-container{display:flex;position:absolute;width:100%;height:100%}.flex-expand{flex:1}.flex-centered{display:flex;align-items:center;justify-content:center}.ratio-height{padding-bottom:14.28571%}.ratio-square{padding-bottom:14.28571%;width:14.28571%}.stretch-vertically{height:100%}.stretch-horizontally{width:14.28571%}.fixed-height{display:flex;flex:1}.w-100{width:100%}.sc-month{font-size:2rem}.sc-month--disabled{opacity:.25}.sc-month__caption,.sc-month__week-caption{border:1px solid #000;font-weight:700}.sc-month__day{border:1px solid #000;cursor:pointer}.sc-month__day--disabled{cursor:auto}.sc-month__day--today{background:pink}.sc-month__day--selected{background:#6495ed}`],
                providers: [MONTH_CALENDAR_VALUE_ACCESSOR]
            },] },
];
MonthCalendarComponent.propDecorators = {
    dayTemplate: [{ type: ContentChild, args: [DayTemplateDirective, { read: TemplateRef },] }],
    dayOfWeekTemplate: [{ type: ContentChild, args: [DayOfWeekCaptionTemplateDirective, { read: TemplateRef },] }],
    monthTemplate: [{ type: ContentChild, args: [MonthCaptionTemplateDirective, { read: TemplateRef },] }],
    change: [{ type: Output, args: ['change',] }],
    monthClick: [{ type: Output, args: ['monthClick',] }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    grow: [{ type: Input }],
    firstDayOfWeek: [{ type: Input }],
    dayFormatter: [{ type: Input }],
    dayOfWeekCaptionFormatter: [{ type: Input }],
    monthCaptionFormatter: [{ type: Input }],
    customDayClass: [{ type: Input }],
    monthClass: [{ type: Input }],
    disabledClass: [{ type: Input }],
    monthCaptionClass: [{ type: Input }],
    dayOfWeekCaptionClass: [{ type: Input }],
    dayCaptionClass: [{ type: Input }],
    currentDayClass: [{ type: Input }],
    disabledDayClass: [{ type: Input }],
    selectedDayClass: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Represents information about one
 * day of the month.
 */
class DayInfo {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class MonthCalendarModule {
}
MonthCalendarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    BrowserModule,
                    FormsModule
                ],
                declarations: [
                    MonthCalendarComponent,
                    MonthCaptionTemplateDirective,
                    DayOfWeekCaptionTemplateDirective,
                    DayTemplateDirective
                ],
                exports: [
                    MonthCalendarComponent,
                    MonthCaptionTemplateDirective,
                    DayOfWeekCaptionTemplateDirective,
                    DayTemplateDirective
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { MONTH_CALENDAR_VALUE_ACCESSOR, MonthCalendarComponent, MonthCaptionTemplateDirective, DayOfWeekCaptionTemplateDirective, DayTemplateDirective, DayInfo, DayOfWeek, MonthCalendarModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2ltcGxlLWFuZ3VsYXItY2FsZW5kYXIuanMubWFwIiwic291cmNlcyI6WyJuZzovL3NpbXBsZS1hbmd1bGFyLWNhbGVuZGFyL2xpYi9tb2RlbHMvZGF5LW5hbWVzLnRzIiwibmc6Ly9zaW1wbGUtYW5ndWxhci1jYWxlbmRhci9saWIvbW9kZWxzL2RheS1vZi13ZWVrLnRzIiwibmc6Ly9zaW1wbGUtYW5ndWxhci1jYWxlbmRhci9saWIvbW9kZWxzL2RhdGVzL2RhdGUtbWF0aC50cyIsIm5nOi8vc2ltcGxlLWFuZ3VsYXItY2FsZW5kYXIvbGliL21vZGVscy92aWV3cy9tb3RoLXZpZXcudHMiLCJuZzovL3NpbXBsZS1hbmd1bGFyLWNhbGVuZGFyL2xpYi9kaXJlY3RpdmVzL2RheS10ZW1wbGF0ZS5kaXJlY3RpdmUudHMiLCJuZzovL3NpbXBsZS1hbmd1bGFyLWNhbGVuZGFyL2xpYi9kaXJlY3RpdmVzL2RheS1vZi13ZWVrLWNhcHRpb24tdGVtcGxhdGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9zaW1wbGUtYW5ndWxhci1jYWxlbmRhci9saWIvZGlyZWN0aXZlcy9tb250aC1jYXB0aW9uLXRlbXBsYXRlLmRpcmVjdGl2ZS50cyIsIm5nOi8vc2ltcGxlLWFuZ3VsYXItY2FsZW5kYXIvbGliL21vZGVscy9mb3JtYXR0ZXJzL2RheS1vZi13ZWVrLWNhcHRpb24tZm9ybWF0dGVyLnRzIiwibmc6Ly9zaW1wbGUtYW5ndWxhci1jYWxlbmRhci9saWIvY29tcG9uZW50cy9tb250aC1jYWxlbmRhci9tb250aC1jYWxlbmRhci5jb21wb25lbnQudHMiLCJuZzovL3NpbXBsZS1hbmd1bGFyLWNhbGVuZGFyL2xpYi9tb2RlbHMvZGF5LWluZm8udHMiLCJuZzovL3NpbXBsZS1hbmd1bGFyLWNhbGVuZGFyL2xpYi9tb250aC1jYWxlbmRhci5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBOYW1lcyBvZiB0aGUgZGF5cyBvZiB0aGUgd2VlayBpbiBFbmdsaXNoLlxuICovXG5leHBvcnQgY29uc3QgREFZX05BTUVTID0gW1xuICAgICdTdW5kYXknLFxuICAgICdNb25kYXknLFxuICAgICdUdWVzZGF5JyxcbiAgICAnV2VkbmVzZGF5JyxcbiAgICAnVGh1cnNkYXknLFxuICAgICdGcmlkYXknLFxuICAgICdTYXR1cmRheScgICAgXG5dOyIsIi8qKlxuICogUmVwcmVzZW50cyBhIGRheSBvZiB0aGUgd2Vlay5cbiAqL1xuZXhwb3J0IGVudW0gRGF5T2ZXZWVrIHtcbiAgU3VuZGF5ID0gMCxcbiAgTW9uZGF5ID0gMSxcbiAgVHVlc2RheSA9IDIsXG4gIFdlZG5lc2RheSA9IDMsXG4gIFRodXJzZGF5ID0gNCxcbiAgRnJpZGF5ID0gNSxcbiAgU2F0dXJkYXkgPSA2XG59XG4iLCIvKipcbiAqIENvbnRhaW5zIHNldmVyYWwgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICogZGF0ZXMgaW4gSlMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRlTWF0aCB7XG5cbiAgICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZGF5cyB0byB0aGUgc3BlY2lmaWVkIGRhdGUuXG4gICAgICogQHBhcmFtIGRhdGUgRGF0ZSB0aGF0IHdpbGwgYmUgaW5jcmVhc2VkLlxuICAgICAqIEBwYXJhbSBkYXlzIE51bWJlciBvZiBkYXlzIHRvIGFkZCB0byB0aGUgc3BlY2lmaWVkXG4gICAgICogZGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGF5cyhkYXRlOiBEYXRlLCBkYXlzOiBudW1iZXIpOiBEYXRlIHtcbiAgICAgICAgY29uc3QgZGF5c0FkZGVkID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkpO1xuICAgICAgICBkYXlzQWRkZWQuc2V0RGF0ZShkYXlzQWRkZWQuZ2V0RGF0ZSgpICsgZGF5cyk7XG4gICAgICAgIHJldHVybiBkYXlzQWRkZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Vic3RyYWN0IGRheXMgdG8gdGhlIHNwZWNpZmllZCBkYXRlLlxuICAgICAqIEBwYXJhbSBkYXRlIERhdGUgdGhhdCB3aWxsIGJlIGRlY3JlYXNlZC5cbiAgICAgKiBAcGFyYW0gZGF5cyBOdW1iZXIgb2YgZGF5cyB0byBzdWJzdHJhY3QgZnJvbVxuICAgICAqIHRoZSBzcGVjaWZpZWQgZGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3Vic3RyYWN0RGF5cyhkYXRlOiBEYXRlLCBkYXlzOiBudW1iZXIpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIERhdGVNYXRoLmFkZERheXMoZGF0ZSwgLWRheXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBudW1iZXIgb2YgbW9udGhzIHRvIHRoZSBzcGVjaWZpZWQgZGF0ZS5cbiAgICAgKiBAcGFyYW0gZGF0ZSBEYXRlIHRoYXQgd2lsbCBiZSBpbmNyZWFzZWQuXG4gICAgICogQHBhcmFtIG1vbnRocyBNb250aHMgdG8gYWRkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRNb250aHMoZGF0ZTogRGF0ZSwgbW9udGhzOiBudW1iZXIpOiBEYXRlIHtcbiAgICAgIGNvbnN0IG1vbnRoc0FkZGVkID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkpO1xuICAgICAgbW9udGhzQWRkZWQuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgbW9udGhzKTtcbiAgICAgIHJldHVybiBtb250aHNBZGRlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzdHJhY3RzIGEgbnVtYmVyIG9mIG1vbnRocyBmcm9tIHRoZSBzcGVjaWZpZWQgZGF0ZS5cbiAgICAgKiBAcGFyYW0gZGF0ZSBEYXRlIHRoYXQgd2lsbCBiZSBkZWNyZWFzZWQuXG4gICAgICogQHBhcmFtIG1vbnRocyBNb250aHMgdG8gc3Vic3RyYWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBzdWJzdHJhY3RNb250aHMoZGF0ZTogRGF0ZSwgbW9udGhzOiBudW1iZXIpOiBEYXRlIHtcbiAgICAgIGNvbnN0IG1vbnRoc1N1YnN0cmFjdGVkID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkpO1xuICAgICAgbW9udGhzU3Vic3RyYWN0ZWQuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpIC0gbW9udGhzKTtcbiAgICAgIHJldHVybiBtb250aHNTdWJzdHJhY3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZpcnN0IGRheVxuICAgICAqIG9mIHRoZSBtb250aCBvZiB0aGUgc3BlY2lmaWVkIGRhdGUuXG4gICAgICogQHBhcmFtIGRhdGUgRGF0ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Rmlyc3REYXlPZk1vbnRoKGRhdGU6IERhdGUpOiBEYXRlIHtcbiAgICAgICAgY29uc3QgZmlyc3REYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBmaXJzdERheS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgMSk7XG4gICAgICAgIHJldHVybiBmaXJzdERheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxhc3QgZGF5XG4gICAgICogb2YgdGhlIG1vbnRoIG9mIHRoZSBzcGVjaWZpZWQgZGF0ZS5cbiAgICAgKiBAcGFyYW0gZGF0ZSBEYXRlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRMYXN0RGF5T2ZNb250aChkYXRlOiBEYXRlKTogRGF0ZSB7XG4gICAgICAgIGNvbnN0IGxhc3REYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsYXN0RGF5LnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgMCk7XG4gICAgICAgIHJldHVybiBsYXN0RGF5O1xuICAgIH1cbn1cbiIsImltcG9ydCB7IERheU9mV2VlayB9IGZyb20gJy4uL2RheS1vZi13ZWVrJztcbmltcG9ydCB7IERhdGVNYXRoIH0gZnJvbSAnLi4vZGF0ZXMvZGF0ZS1tYXRoJztcbmltcG9ydCB7IERheUluZm8gfSBmcm9tICcuLi9kYXktaW5mbyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHZpZXcgb2YgYSBtb250aC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vbnRoVmlldyB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBXRUVLU19QRVJfTU9OVEggPSA1O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgREFZU19QRVJfV0VFSyA9IDc7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgTW9udGhWaWV3LlxuICAgKiBAcGFyYW0gZGF0ZSBEYXRlIG9mIHRoZSBtb250aC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZTogRGF0ZSkge31cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZ3JpZCBjb3JyZXNwb25kaW5nIHRvIHRoZSBtb250aCBzcGVjaWZpZWRcbiAgICogYnkgdGhlIGRhdGUuXG4gICAqIEBwYXJhbSBjb21wbGV0ZUhvbGVzIEluZGljYXRlcyBpZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmRcbiAgICogb2YgdGhlIGdyaWQgc2hvdWxkIGJlIGNvbXBsZXRlZCB3aXRoIHRoZSBkYXlzIG9mIHRoZVxuICAgKiBhZGphY2VudCBtb250aHMuXG4gICAqIEBwYXJhbSB3ZWVrU3RhcnQgRGF5IG9mIHdlZWsgdG8gYmUgY29uc2lkZXJlZCB0aGUgYmVnaW5uaW5nXG4gICAqIG9mIHRoZSB3ZWVrLlxuICAgKi9cbiAgY3JlYXRlVmlldyhjb21wbGV0ZUhvbGVzID0gZmFsc2UsIHdlZWtTdGFydCA9IERheU9mV2Vlay5Nb25kYXkpOiBBcnJheTxBcnJheTxEYXlJbmZvPj4ge1xuICAgIGNvbnN0IGN1cnJlbnRNb250aEdyaWQgPSB0aGlzLmNyZWF0ZUdyaWQodGhpcy5kYXRlLCB3ZWVrU3RhcnQpO1xuXG4gICAgaWYgKGNvbXBsZXRlSG9sZXMpIHtcbiAgICAgIGNvbnN0IG5lZWRzVG9CZUZpbGxlZEZyb21CZWdpbm5pbmcgPSAhISFjdXJyZW50TW9udGhHcmlkWzBdWzBdO1xuXG4gICAgICBpZiAobmVlZHNUb0JlRmlsbGVkRnJvbUJlZ2lubmluZykge1xuICAgICAgICBjb25zdCBsYXN0TW9udGggPSBEYXRlTWF0aC5zdWJzdHJhY3RNb250aHModGhpcy5kYXRlLCAxKTtcbiAgICAgICAgY29uc3QgbGFzdERheU9mTGFzdE1vbnRoID0gRGF0ZU1hdGguZ2V0TGFzdERheU9mTW9udGgobGFzdE1vbnRoKS5nZXREYXRlKCk7XG5cbiAgICAgICAgY29uc3QgZmlyc3REYXlPZkN1cnJlbnRNb250aCA9IERhdGVNYXRoLmdldEZpcnN0RGF5T2ZNb250aCh0aGlzLmRhdGUpO1xuICAgICAgICBjb25zdCBkYXlzVG9QaWNrRnJvbUxhc3RNb250aCA9IGZpcnN0RGF5T2ZDdXJyZW50TW9udGguZ2V0RGF5KCkgLSB3ZWVrU3RhcnQudmFsdWVPZigpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF5c1RvUGlja0Zyb21MYXN0TW9udGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnREYXlPZk1vbnRoID0gbGFzdERheU9mTGFzdE1vbnRoIC0gKGRheXNUb1BpY2tGcm9tTGFzdE1vbnRoIC0gKGkgKyAxKSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZShsYXN0TW9udGguZ2V0RnVsbFllYXIoKSwgbGFzdE1vbnRoLmdldE1vbnRoKCksIGN1cnJlbnREYXlPZk1vbnRoKTtcblxuICAgICAgICAgIGN1cnJlbnRNb250aEdyaWRbMF1baV0gPSB7XG4gICAgICAgICAgICBpc1RvZGF5OiBmYWxzZSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgZGF5OiBjdXJyZW50RGF5T2ZNb250aCxcbiAgICAgICAgICAgIGRhdGU6IGN1cnJlbnREYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZmlsbGluZ0RheXMgPSAxO1xuICAgICAgZm9yIChsZXQgd2VlayA9IDA7IHdlZWsgPCB0aGlzLldFRUtTX1BFUl9NT05USDsgd2VlaysrKSB7XG4gICAgICAgIGZvciAobGV0IGRheU9mV2VlayA9IDA7IGRheU9mV2VlayA8IHRoaXMuREFZU19QRVJfV0VFSzsgZGF5T2ZXZWVrKyspIHtcbiAgICAgICAgICBpZiAoISEhY3VycmVudE1vbnRoR3JpZFt3ZWVrXVtkYXlPZldlZWtdKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbGxpbmdEYXRlcyA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSwgZmlsbGluZ0RheXMrKyk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRNb250aEdyaWRbd2Vla11bZGF5T2ZXZWVrXSA9IHtcbiAgICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBkYXk6IGZpbGxpbmdEYXlzLFxuICAgICAgICAgICAgICBkYXRlOiBmaWxsaW5nRGF0ZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRNb250aEdyaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZ3JpZCBjb3JyZXNwb25kaW5nIHRvIHRoZSBtb250aCBzcGVjaWZpZWRcbiAgICogYnkgdGhlIGRhdGUuXG4gICAqIEBwYXJhbSBkYXRlIERhdGUgdG8gdXNlLlxuICAgKiBAcGFyYW0gd2Vla1N0YXJ0IERheSBvZiB3ZWVrIHdoaWNoIHdpbGwgYmUgY29uc2lkZXJlZFxuICAgKiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB3ZWVrLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVHcmlkKGRhdGU6IERhdGUsIHdlZWtTdGFydCA9IERheU9mV2Vlay5Nb25kYXkpOiBBcnJheTxBcnJheTxEYXlJbmZvPj4ge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLmluaXRHcmlkKCk7XG4gICAgY29uc3QgZmlyc3REYXlPZldlZWsgPVxuICAgICAgRGF0ZU1hdGguZ2V0Rmlyc3REYXlPZk1vbnRoKGRhdGUpLmdldERheSgpIC0gd2Vla1N0YXJ0LnZhbHVlT2YoKTtcbiAgICBjb25zdCBsYXN0RGF5ID0gRGF0ZU1hdGguZ2V0TGFzdERheU9mTW9udGgoZGF0ZSkuZ2V0RGF0ZSgpO1xuXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIGxldCBkYXlPZldlZWsgPSBmaXJzdERheU9mV2VlaztcbiAgICBsZXQgY3VycmVudERheU9mTW9udGggPSAxO1xuICAgIGZvciAobGV0IHdlZWsgPSAwOyB3ZWVrIDwgdGhpcy5XRUVLU19QRVJfTU9OVEg7IHdlZWsrKykge1xuXG4gICAgICBmb3IgKDsgZGF5T2ZXZWVrIDwgdGhpcy5EQVlTX1BFUl9XRUVLICYmIGN1cnJlbnREYXlPZk1vbnRoIDw9IGxhc3REYXk7IGRheU9mV2VlaysrKSB7XG4gICAgICAgIGNvbnN0IHRvZGF5U2FtZVllYXIgPSB0b2RheS5nZXRGdWxsWWVhcigpID09PSB0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgdG9kYXlTYW1lTW9udGggPSB0b2RheS5nZXRNb250aCgpID09PSB0aGlzLmRhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgY29uc3QgdG9kYXlTYW1lRGF5ID0gdG9kYXkuZ2V0RGF0ZSgpID09PSBjdXJyZW50RGF5T2ZNb250aDtcbiAgICAgICAgY29uc3QgY3VycmVudERhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKSwgdGhpcy5kYXRlLmdldE1vbnRoKCksIGN1cnJlbnREYXlPZk1vbnRoKTtcblxuICAgICAgICBncmlkW3dlZWtdW2RheU9mV2Vla10gPSB7XG4gICAgICAgICAgaXNUb2RheTogdG9kYXlTYW1lWWVhciAmJiB0b2RheVNhbWVNb250aCAmJiB0b2RheVNhbWVEYXksXG4gICAgICAgICAgaXNTZWxlY3RlZDogdGhpcy5kYXRlLmdldERhdGUoKSA9PT0gY3VycmVudERheU9mTW9udGgsXG4gICAgICAgICAgZGF5OiBjdXJyZW50RGF5T2ZNb250aCxcbiAgICAgICAgICBkYXRlOiBjdXJyZW50RGF0ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGN1cnJlbnREYXlPZk1vbnRoKys7XG4gICAgICB9XG5cbiAgICAgIGRheU9mV2VlayA9IDA7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZ3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZ3JpZCB0aGF0IGNvbnRhaW5zXG4gICAqIHRoZSBpbmZvIGFib3V0IHRoZSBcInNoYXBlXCIgb2YgdGhlXG4gICAqIG1vbnRoLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0R3JpZCgpOiBBcnJheTxBcnJheTxEYXlJbmZvPj4ge1xuICAgIGNvbnN0IGRlZmF1bHRFbXB0eSA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBncmlkID0gW1xuICAgICAgbmV3IEFycmF5KHRoaXMuREFZU19QRVJfV0VFSykuZmlsbChkZWZhdWx0RW1wdHkpLFxuICAgICAgbmV3IEFycmF5KHRoaXMuREFZU19QRVJfV0VFSykuZmlsbChkZWZhdWx0RW1wdHkpLFxuICAgICAgbmV3IEFycmF5KHRoaXMuREFZU19QRVJfV0VFSykuZmlsbChkZWZhdWx0RW1wdHkpLFxuICAgICAgbmV3IEFycmF5KHRoaXMuREFZU19QRVJfV0VFSykuZmlsbChkZWZhdWx0RW1wdHkpLFxuICAgICAgbmV3IEFycmF5KHRoaXMuREFZU19QRVJfV0VFSykuZmlsbChkZWZhdWx0RW1wdHkpXG4gICAgXTtcblxuICAgIHJldHVybiBncmlkO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBEaXJlY3RpdmUgdG8gc2VsZWN0IHRoZSB0ZW1wbGF0ZSB0byB1c2VcbiAqIGZvciB0aGUgZGF5IGNlbGwuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tzY0RheVRlbXBsYXRlXSdcbn0pXG5leHBvcnQgY2xhc3MgRGF5VGVtcGxhdGVEaXJlY3RpdmUge1xuXG4gIGNvbnN0cnVjdG9yKCkgeyB9XG5cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbc2NEYXlPZldlZWtDYXB0aW9uVGVtcGxhdGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBEYXlPZldlZWtDYXB0aW9uVGVtcGxhdGVEaXJlY3RpdmUge1xuXG4gIGNvbnN0cnVjdG9yKCkgeyB9XG5cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbc2NNb250aENhcHRpb25UZW1wbGF0ZV0nXG59KVxuZXhwb3J0IGNsYXNzIE1vbnRoQ2FwdGlvblRlbXBsYXRlRGlyZWN0aXZlIHtcblxuICBjb25zdHJ1Y3RvcigpIHsgfVxuXG59XG4iLCJpbXBvcnQgeyBEQVlfTkFNRVMgfSBmcm9tICcuLi9kYXktbmFtZXMnO1xuaW1wb3J0IHsgRGF5T2ZXZWVrIH0gZnJvbSAnLi4vZGF5LW9mLXdlZWsnO1xuXG4vKipcbiAqIERlZmF1bHQgZm9ybWF0dGVyIGZvciB0aGUgY2FwdGlvbnMgb2YgdGhlIGRheXNcbiAqIG9mIHRoZSB3ZWVrLlxuICogQHBhcmFtIGRheU9mV2VlayBEYXkgb2YgdGhlIHdlZWsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0RGF5T2ZXZWVrQ2FwdGlvbkZvcm1hdHRlckZhY3RvcnkoZmlyc3REYXlPZldlZWs6IERheU9mV2Vlayk6IChkYXlPZldlZWs6IERheU9mV2VlaykgPT4gc3RyaW5nIHtcbiAgcmV0dXJuIChkYXlPZldlZWs6IERheU9mV2VlaykgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHRlZERheU5hbWVzID0gREFZX05BTUVTLm1hcChcbiAgICAgIGRheU5hbWUgPT4gZm9ybWF0RGF5TmFtZShkYXlOYW1lKVxuICAgICk7XG5cbiAgICBjb25zdCByZW9yZGVyZWQgPSByZW9yZGVyRGF5cyhmb3JtYXR0ZWREYXlOYW1lcywgZmlyc3REYXlPZldlZWspO1xuICAgIHJldHVybiByZW9yZGVyZWRbZGF5T2ZXZWVrLnZhbHVlT2YoKV07XG4gIH07XG59XG5cbi8qKlxuICogQXBwbGllcyBmb3JtYXR0aW5nIHRvIHRoZSBuYW1lIG9mIHRoZSBkYXkuXG4gKiBAcGFyYW0gZGF5TmFtZSBOYW1lIG9mIHRoZSBkYXkuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdERheU5hbWUoZGF5TmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbmV3RGF5TmFtZSA9IGRheU5hbWUuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBkYXlOYW1lLnN1YnN0cigxLCAxKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbmV3RGF5TmFtZTtcbn1cblxuLyoqXG4gKiBSZW9yZGVycyB0aGUgYXJyYXkgb2YgbmFtZXMgc28gdGhlIGZpcnN0IGluZGV4XG4gKiBjb3JyZXNwb25kcyB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmaXJzdCBkYXkgb2ZcbiAqIHRoZSB3ZWVrLlxuICogQHBhcmFtIGRheU5hbWVzIEFycmF5IHdpdGggdGhlIG5hbWVzIG9mIHRoZSBkYXlzXG4gKiBvZiB0aGUgd2Vlay5cbiAqIEBwYXJhbSBmaXJzdERheU9mV2VlayBGaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gKi9cbmZ1bmN0aW9uIHJlb3JkZXJEYXlzKGRheU5hbWVzOiBzdHJpbmdbXSwgZmlyc3REYXlPZldlZWs6IERheU9mV2Vlayk6IHN0cmluZ1tdIHtcbiAgY29uc3QgZGF5Q291bnQgPSBEQVlfTkFNRVMubGVuZ3RoO1xuXG4gIGNvbnN0IGRheUluZGV4ID0gZmlyc3REYXlPZldlZWsudmFsdWVPZigpO1xuICBjb25zdCByZW9yZGVyZWQgPSAobmV3IEFycmF5KGRheUNvdW50KSkuZmlsbCgwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXlDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSAoaSArIGRheUluZGV4KSAlIGRheUNvdW50O1xuICAgIHJlb3JkZXJlZFtpXSA9IGRheU5hbWVzW25ld1Bvc2l0aW9uXTtcbiAgfVxuXG4gIHJldHVybiByZW9yZGVyZWQ7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBPdXRwdXQsIENvbnRlbnRDaGlsZCwgVGVtcGxhdGVSZWYsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRGF5SW5mbyB9IGZyb20gJy4uLy4uL21vZGVscy9kYXktaW5mbyc7XG5pbXBvcnQgeyBEQVlfTkFNRVMgfSBmcm9tICcuLi8uLi9tb2RlbHMvZGF5LW5hbWVzJztcbmltcG9ydCB7IE1vbnRoVmlldyB9IGZyb20gJy4uLy4uL21vZGVscy92aWV3cy9tb3RoLXZpZXcnO1xuaW1wb3J0IHsgRGF5VGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RheS10ZW1wbGF0ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRGF5T2ZXZWVrQ2FwdGlvblRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9kYXktb2Ytd2Vlay1jYXB0aW9uLXRlbXBsYXRlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNb250aENhcHRpb25UZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvbW9udGgtY2FwdGlvbi10ZW1wbGF0ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRGF5T2ZXZWVrIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2RheS1vZi13ZWVrJztcbmltcG9ydCB7IGRlZmF1bHREYXlPZldlZWtDYXB0aW9uRm9ybWF0dGVyRmFjdG9yeSB9IGZyb20gJy4uLy4uL21vZGVscy9mb3JtYXR0ZXJzL2RheS1vZi13ZWVrLWNhcHRpb24tZm9ybWF0dGVyJztcbmltcG9ydCB7IEdyb3dNb2RlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2dyb3ctbW9kZSc7XG5cbi8qKlxuICogTW9udGggY2FsZW5kYXIgcHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBNT05USF9DQUxFTkRBUl9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTW9udGhDYWxlbmRhckNvbXBvbmVudCksXG4gIG11bHRpOiB0cnVlXG59O1xuXG4vKipcbiAqIENvbnRyb2wgdGhhdCByZXByZXNlbnRzIGEgY2FsZW5kYXIuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3NjLW1vbnRoLWNhbGVuZGFyJyxcbiAgdGVtcGxhdGU6IGA8IS0tIE1vbnRoIC0tPlxuPGRpdiAoY2xpY2spPVwib25Nb250aENsaWNrKClcIlxuICAgICBbbmdDbGFzc109XCJbJ2NvbHVtbicsIGdyb3cubW9kZSA9PSAnc3RyZXRjaCcgPyAnc3RyZXRjaC12ZXJ0aWNhbGx5JyA6ICcnLCBnZXRDbGFzc0Zvck1vbnRoKCldXCI+XG5cbiAgPCEtLSBNb250aCBjYXB0aW9uIC0tPlxuICA8ZGl2IGNsYXNzPVwicm93XCI+XG5cbiAgICA8IS0tIE1vbnRoIGNhcHRpb24gY2VsbCAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidy0xMDBcIlxuICAgICAgICAgW2NsYXNzLmxhYmVsXT1cImdyb3cubW9kZSAhPSAnbWl4ZWQnXCJcbiAgICAgICAgIFtjbGFzcy5yYXRpby1oZWlnaHRdPVwiZ3Jvdy5tb2RlID09ICdwcm9wb3J0aW9uYWwnXCJcbiAgICAgICAgIFtjbGFzcy5zdHJldGNoLWhvcml6b250YWxseV09XCJncm93Lm1vZGUgPT0gJ3N0cmV0Y2gnIHx8IGdyb3cubW9kZSA9PSAnbWl4ZWQnXCI+XG5cbiAgICAgIDwhLS0gTW9udGggY2FwdGlvbiBjZWxsIGNvbnRlbnQgLS0+XG4gICAgICA8ZGl2IFtjbGFzcy5sYWJlbF9fY29udGVudF09XCJncm93Lm1vZGUgIT0gJ21peGVkJ1wiPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJtb250aFRlbXBsYXRlID8gbW9udGhUZW1wbGF0ZSA6IGRlZmF1bHRNb250aFRlbXBsYXRlOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogdmFsdWUgfVwiPjwvbmctY29udGFpbmVyPlxuXG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPCEtLSBXZWVrIGNhcHRpb25zIC0tPlxuICA8ZGl2IGNsYXNzPVwicm93XCI+XG5cbiAgICA8IS0tIFdlZWsgY2FwdGlvbnMgY2VsbCAtLT5cbiAgICA8ZGl2IFtjbGFzcy5sYWJlbF09XCJncm93Lm1vZGUgIT0gJ21peGVkJ1wiXG4gICAgICAgICBbY2xhc3MucmF0aW8tc3F1YXJlXT1cImdyb3cubW9kZSA9PSAncHJvcG9ydGlvbmFsJ1wiXG4gICAgICAgICBbY2xhc3Muc3RyZXRjaC1ob3Jpem9udGFsbHldPVwiZ3Jvdy5tb2RlID09ICdzdHJldGNoJyB8fCBncm93Lm1vZGUgPT0gJ21peGVkJ1wiXG4gICAgICAgICAqbmdGb3I9XCJsZXQgZGF5T2ZXZWVrQ2FwdGlvbiBvZiBkYXlzT2ZXZWVrQ2FwdGlvbnM7IGxldCBpID0gaW5kZXhcIj5cblxuICAgICAgPCEtLSBXZWVrIGNhcHRpb24gY2VsbCBjb250ZW50IC0tPlxuICAgICAgPGRpdiBbY2xhc3MubGFiZWxfX2NvbnRlbnRdPVwiZ3Jvdy5tb2RlICE9ICdtaXhlZCdcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZGF5T2ZXZWVrVGVtcGxhdGUgPyBkYXlPZldlZWtUZW1wbGF0ZSA6IGRlZmF1bHREYXlPZldlZWtUZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IGRheU9mV2Vla0NhcHRpb24sIGRheU9mV2Vla0luZGV4OiBpIH1cIj48L25nLWNvbnRhaW5lcj5cblxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDwhLS0gRGF5cyAtLT5cbiAgPGRpdiBjbGFzcz1cInJvd1wiXG4gICAgICAgKm5nRm9yPVwibGV0IHdlZWsgb2Ygdmlld1wiPlxuXG4gICAgPCEtLSBEYXkgY2VsbCAtLT5cbiAgICA8ZGl2IChjbGljayk9XCJvbkRheUNsaWNrKGRheSlcIlxuICAgICAgICAgY2xhc3M9XCJyYXRpby1zcXVhcmUgbGFiZWxcIlxuICAgICAgICAgW2NsYXNzLnJhdGlvLXNxdWFyZV09XCJncm93Lm1vZGUgPT0gJ3Byb3BvcnRpb25hbCcgfHwgZ3Jvdy5tb2RlID09ICdtaXhlZCdcIlxuICAgICAgICAgW2NsYXNzLnN0cmV0Y2gtaG9yaXpvbnRhbGx5XT1cImdyb3cubW9kZSA9PSAnc3RyZXRjaCdcIlxuICAgICAgICAgKm5nRm9yPVwibGV0IGRheSBvZiB3ZWVrXCI+XG5cbiAgICAgIDwhLS0gRGF5IGNvbnRlbnQgLS0+XG4gICAgICA8ZGl2IGNsYXNzPVwibGFiZWxfX2NvbnRlbnRcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZGF5VGVtcGxhdGUgPyBkYXlUZW1wbGF0ZSA6IGRlZmF1bHREYXlUZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IGRheSB9XCI+PC9uZy1jb250YWluZXI+XG5cbiAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgPC9kaXY+XG5cbjwvZGl2PlxuXG5cblxuPCEtLSBUZW1wbGF0ZXMgLS0+XG5cbjwhLS0gRGF5IHRlbXBsYXRlIC0tPlxuPG5nLXRlbXBsYXRlICNkZWZhdWx0RGF5VGVtcGxhdGVcbiAgICAgICAgICAgICBsZXQtZGF5PlxuICA8ZGl2IGNsYXNzPVwiZmxleC1leHBhbmRlZC1jb250YWluZXJcIj5cbiAgICA8ZGl2IFtuZ0NsYXNzXT1cIlsnZmxleC1leHBhbmQnLCBnZXRDbGFzc0ZvckRheShkYXkpXVwiPnt7IGdldEZvcm1hdHRlZERheShkYXkpIH19PC9kaXY+XG4gIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLSBEYXkgb2Ygd2VlayBjZWxscyB0ZW1wbGF0ZSAtLT5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdERheU9mV2Vla1RlbXBsYXRlXG4gICAgICAgICAgICAgbGV0LWRheU9mV2Vla1xuICAgICAgICAgICAgIGxldC1kYXlPZldlZWtJbmRleD1cImRheU9mV2Vla0luZGV4XCI+XG4gIDxkaXYgW2NsYXNzLmZsZXgtZXhwYW5kZWQtY29udGFpbmVyXT1cImdyb3cubW9kZSAhPSAnbWl4ZWQnXCI+XG4gICAgPGRpdiBbbmdDbGFzc109XCJbJ2ZsZXgtZXhwYW5kJywgJ2ZsZXgtY2VudGVyZWQnLCBkYXlPZldlZWtDYXB0aW9uQ2xhc3NdXCI+XG4gICAgICB7eyBkYXlPZldlZWsgfX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tIE1vbnRoIGNlbGwgdGVtcGxhdGUgLS0+XG48bmctdGVtcGxhdGUgI2RlZmF1bHRNb250aFRlbXBsYXRlXG4gICAgICAgICAgICAgbGV0LWRhdGU+XG4gIDxkaXYgW2NsYXNzLmZsZXgtZXhwYW5kZWQtY29udGFpbmVyXT1cImdyb3cubW9kZSAhPSAnbWl4ZWQnXCI+XG4gICAgPGRpdiBbbmdDbGFzc109XCJbJ2ZsZXgtZXhwYW5kJywgJ2ZsZXgtY2VudGVyZWQnLCBtb250aENhcHRpb25DbGFzc11cIj5cbiAgICAgIHt7IG1vbnRoQ2FwdGlvbiB9fVxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICBzdHlsZXM6IFtgLmNvbHVtbntkaXNwbGF5OmZsZXg7ZmxleC1mbG93OmNvbHVtbjtmbGV4OjF9LnJvd3tkaXNwbGF5OmZsZXg7ZmxleDoxfS5sYWJlbHtwb3NpdGlvbjpyZWxhdGl2ZX0ubGFiZWxfX2NvbnRlbnR7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjB9LmZsZXgtZXhwYW5kZWQtY29udGFpbmVye2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfS5mbGV4LWV4cGFuZHtmbGV4OjF9LmZsZXgtY2VudGVyZWR7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5yYXRpby1oZWlnaHR7cGFkZGluZy1ib3R0b206MTQuMjg1NzElfS5yYXRpby1zcXVhcmV7cGFkZGluZy1ib3R0b206MTQuMjg1NzElO3dpZHRoOjE0LjI4NTcxJX0uc3RyZXRjaC12ZXJ0aWNhbGx5e2hlaWdodDoxMDAlfS5zdHJldGNoLWhvcml6b250YWxseXt3aWR0aDoxNC4yODU3MSV9LmZpeGVkLWhlaWdodHtkaXNwbGF5OmZsZXg7ZmxleDoxfS53LTEwMHt3aWR0aDoxMDAlfS5zYy1tb250aHtmb250LXNpemU6MnJlbX0uc2MtbW9udGgtLWRpc2FibGVke29wYWNpdHk6LjI1fS5zYy1tb250aF9fY2FwdGlvbiwuc2MtbW9udGhfX3dlZWstY2FwdGlvbntib3JkZXI6MXB4IHNvbGlkICMwMDA7Zm9udC13ZWlnaHQ6NzAwfS5zYy1tb250aF9fZGF5e2JvcmRlcjoxcHggc29saWQgIzAwMDtjdXJzb3I6cG9pbnRlcn0uc2MtbW9udGhfX2RheS0tZGlzYWJsZWR7Y3Vyc29yOmF1dG99LnNjLW1vbnRoX19kYXktLXRvZGF5e2JhY2tncm91bmQ6cGlua30uc2MtbW9udGhfX2RheS0tc2VsZWN0ZWR7YmFja2dyb3VuZDojNjQ5NWVkfWBdLFxuICBwcm92aWRlcnM6IFtNT05USF9DQUxFTkRBUl9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgTW9udGhDYWxlbmRhckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkluaXQge1xuICBAQ29udGVudENoaWxkKERheVRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pIGRheVRlbXBsYXRlO1xuICBAQ29udGVudENoaWxkKERheU9mV2Vla0NhcHRpb25UZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBkYXlPZldlZWtUZW1wbGF0ZTtcbiAgQENvbnRlbnRDaGlsZChNb250aENhcHRpb25UZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBtb250aFRlbXBsYXRlO1xuXG4gIC8qKlxuICAgKiBFdmVudCByYWlzZWQgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgZGF0ZS5cbiAgICovXG4gIEBPdXRwdXQoJ2NoYW5nZScpIGNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZT4oKTtcblxuICAvKipcbiAgICogRXZlbnQgcmFpc2VkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIEBPdXRwdXQoJ21vbnRoQ2xpY2snKSBtb250aENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxNb250aENhbGVuZGFyQ29tcG9uZW50PigpO1xuXG4gIC8qKlxuICAgKiBTZXRzIGlmIHRoZSBjb250cm9sIHNob3VsZCBiZSBpbiBhXG4gICAqIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgQElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogRGF0ZSB0byBzaG93LlxuICAgKi9cbiAgcHJpdmF0ZSBfdmFsdWUgPSBuZXcgRGF0ZSgpO1xuXG4gIGdldCB2YWx1ZSgpOiBEYXRlIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgdmFsdWUoZGF0ZTogRGF0ZSkge1xuICAgIHRoaXMud3JpdGVWYWx1ZShkYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgaG93IGEgZGF5IGNlbGwgc2hvdWxkIGdyb3cuXG4gICAqL1xuICBwcml2YXRlIF9ncm93OiBHcm93TW9kZSA9IHsgbW9kZTogJ3N0cmV0Y2gnIH07XG5cbiAgQElucHV0KCkgc2V0IGdyb3cgKG1vZGU6IEdyb3dNb2RlKSB7XG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIHRoaXMuX2dyb3cgPSBtb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ncm93ID0geyBtb2RlOiAnc3RyZXRjaCcgfTtcbiAgICB9XG4gIH1cblxuICBnZXQgZ3JvdygpOiBHcm93TW9kZSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyb3c7XG4gIH1cblxuICBwcml2YXRlIGRlZmF1bHRGaXJzdERheU9mV2VlayA9IERheU9mV2Vlay5TdW5kYXk7XG5cbiAgcHJpdmF0ZSBkZWZhdWx0RGF5T2ZXZWVrQ2FwdGlvbkZvcm1hdHRlciA9IGRlZmF1bHREYXlPZldlZWtDYXB0aW9uRm9ybWF0dGVyRmFjdG9yeSh0aGlzLmRlZmF1bHRGaXJzdERheU9mV2Vlayk7XG5cbiAgLyoqXG4gICAqIEZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICovXG4gIHByaXZhdGUgX2ZpcnN0RGF5T2ZXZWVrOiBEYXlPZldlZWsgPSB0aGlzLmRlZmF1bHRGaXJzdERheU9mV2VlaztcblxuICBASW5wdXQoKSBzZXQgZmlyc3REYXlPZldlZWsgKGRheU9mV2VlazogRGF5T2ZXZWVrKSB7XG4gICAgdGhpcy5fZmlyc3REYXlPZldlZWsgPSBkYXlPZldlZWs7XG4gICAgdGhpcy5kZWZhdWx0RGF5T2ZXZWVrQ2FwdGlvbkZvcm1hdHRlciA9IGRlZmF1bHREYXlPZldlZWtDYXB0aW9uRm9ybWF0dGVyRmFjdG9yeSh0aGlzLl9maXJzdERheU9mV2Vlayk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBnZXQgZmlyc3REYXlPZldlZWsoKTogRGF5T2ZXZWVrIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3REYXlPZldlZWs7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBkYXlzLlxuICAgKi9cbiAgcHJpdmF0ZSBfZGF5Rm9ybWF0dGVyOiAoZGF5PzogRGF5SW5mbykgPT4gc3RyaW5nO1xuXG4gIEBJbnB1dCgpIHNldCBkYXlGb3JtYXR0ZXIgKGZvcm1hdHRlcjogKGRheT86IERheUluZm8pID0+IHN0cmluZykge1xuICAgIHRoaXMuX2RheUZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIGdldCBkYXlGb3JtYXR0ZXIoKTogKGRheT86IERheUluZm8pID0+IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2RheUZvcm1hdHRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0aW9ucyBvZiB0aGUgZGlmZmVyZW50IGRheXMgb2YgdGhlIHdlZWsuXG4gICAqL1xuICBkYXlzT2ZXZWVrQ2FwdGlvbnM7XG5cbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgdGhlIGNhcHRpb25zIG9mIHRoZSBkaWZmZXJlbnRcbiAgICogZGF5cyBvZiB0aGUgd2Vlay5cbiAgICovXG4gIHByaXZhdGUgX2RheU9mV2Vla0NhcHRpb25Gb3JtYXR0ZXI6IChkYXlPZldlZWs6IERheU9mV2VlaykgPT4gc3RyaW5nO1xuXG4gIEBJbnB1dCgpIHNldCBkYXlPZldlZWtDYXB0aW9uRm9ybWF0dGVyIChmb3JtYXR0ZXI6IChkYXlPZldlZWs6IERheU9mV2VlaykgPT4gc3RyaW5nKSB7XG4gICAgdGhpcy5fZGF5T2ZXZWVrQ2FwdGlvbkZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIGdldCBkYXlPZldlZWtDYXB0aW9uRm9ybWF0dGVyKCk6IChkYXlPZldlZWs6IERheU9mV2VlaykgPT4gc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZGF5T2ZXZWVrQ2FwdGlvbkZvcm1hdHRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0aW9uIG9mIHRoZSBtb250aC5cbiAgICovXG4gIG1vbnRoQ2FwdGlvbjtcblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciB0aGUgbW9udGggY2FwdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX21vbnRoQ2FwdGlvbkZvcm1hdHRlcjogKGRhdGU6IERhdGUpID0+IHN0cmluZztcblxuICBASW5wdXQoKSBzZXQgbW9udGhDYXB0aW9uRm9ybWF0dGVyIChmb3JtYXR0ZXI6IChkYXRlOiBEYXRlKSA9PiBzdHJpbmcpIHtcbiAgICB0aGlzLl9tb250aENhcHRpb25Gb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBnZXQgbW9udGhDYXB0aW9uRm9ybWF0dGVyKCk6IChkYXRlOiBEYXRlKSA9PiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9tb250aENhcHRpb25Gb3JtYXR0ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgQ1NTIGNsYXNzIGZvciB0aGUgc3BlY2lmaWVkIGRheS5cbiAgICovXG4gIEBJbnB1dCgpIGN1c3RvbURheUNsYXNzOiAoZGF5OiBEYXlJbmZvKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENTUyBjbGFzcyBmb3IgdGhlIG1vbnRoLlxuICAgKi9cbiAgQElucHV0KCkgbW9udGhDbGFzcyA9ICdzYy1tb250aCc7XG5cbiAgLyoqXG4gICAqIENTUyBjbGFzcyBmb3IgdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgQElucHV0KCkgZGlzYWJsZWRDbGFzcyA9ICdzYy1tb250aC0tZGlzYWJsZWQnO1xuXG4gIC8qKlxuICAgKiBDU1MgY2xhc3MgZm9yIHRoZSBtb250aCBjYXB0aW9uLlxuICAgKi9cbiAgQElucHV0KCkgbW9udGhDYXB0aW9uQ2xhc3MgPSAnc2MtbW9udGhfX2NhcHRpb24nO1xuXG4gIC8qKlxuICAgKiBDU1MgY2xhc3MgZm9yIHRoZSBkYXkgb2YgdGhlIHdlZWsgY2FwdGlvbnMuXG4gICAqL1xuICBASW5wdXQoKSBkYXlPZldlZWtDYXB0aW9uQ2xhc3MgPSAnc2MtbW9udGhfX3dlZWstY2FwdGlvbic7XG5cbiAgLyoqXG4gICAqIENTUyBjbGFzcyBmb3IgdGhlIGRheSBjYXB0aW9ucy5cbiAgICovXG4gIEBJbnB1dCgpIGRheUNhcHRpb25DbGFzcyA9ICdzYy1tb250aF9fZGF5JztcblxuICAvKipcbiAgICogQ1NTIGNsYXNzIGZvciB0aGUgY3VycmVudCBkYXkuXG4gICAqL1xuICBASW5wdXQoKSBjdXJyZW50RGF5Q2xhc3MgPSAnc2MtbW9udGhfX2RheS0tdG9kYXknO1xuXG4gIC8qKlxuICAgKiBDU1MgY2xhc3MgZm9yIHRoZSBkYXkgd2hlbiB0aGUgc3RhdGUgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBASW5wdXQoKSBkaXNhYmxlZERheUNsYXNzID0gJ3NjLW1vbnRoX19kYXktLWRpc2FibGVkJztcblxuICAvKipcbiAgICogQ1NTIGNsYXNzIGZvciB0aGUgc2VsZWN0ZWQgZGF5LlxuICAgKi9cbiAgQElucHV0KCkgc2VsZWN0ZWREYXlDbGFzcyA9ICdzYy1tb250aF9fZGF5LS1zZWxlY3RlZCc7XG5cbiAgLyoqXG4gICAqIFZpZXcgb2YgdGhlIGN1cnJlbnQgbW9udGguXG4gICAqL1xuICB2aWV3O1xuXG4gIHByaXZhdGUgZGVmYXVsdE1vbnRoQ2FwdGlvbkZvcm1hdHRlciA9IChkYXRlOiBEYXRlKSA9PiBkYXRlLnRvRGF0ZVN0cmluZygpO1xuICBwcml2YXRlIGRlZmF1bHREYXlGb3JtYXR0ZXIgPSAoZGF5PzogRGF5SW5mbykgPT4gZGF5ID8gZGF5LmRheS50b1N0cmluZygpIDogJyc7XG4gIHByaXZhdGUgb25DaGFuZ2UgPSAoZGF0ZTogRGF0ZSkgPT4geyB9O1xuICBwcml2YXRlIG9uVG91Y2hlZCA9ICgpID0+IHsgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgd3JpdGVWYWx1ZShkYXRlOiBEYXRlKTogdm9pZCB7XG4gICAgaWYgKGRhdGUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gZGF0ZTtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgdGhpcy5vbkNoYW5nZShkYXRlKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoZGF0ZTogRGF0ZSkgPT4ge30pOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gIH1cblxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHByaXZhdGUgcmVmcmVzaCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlZnJlc2hNb250aENhcHRpb24odGhpcy52YWx1ZSk7XG4gICAgdGhpcy5yZWZyZXNoRGF5T2ZXZWVrQ2FwdGlvbnMoKTtcbiAgICB0aGlzLnJlZnJlc2hWaWV3KHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyB0aGUgbW9udGggY2FwdGlvbi5cbiAgICogQHBhcmFtIGRhdGUgRGF0ZS5cbiAgICovXG4gIHByaXZhdGUgcmVmcmVzaE1vbnRoQ2FwdGlvbihkYXRlOiBEYXRlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubW9udGhDYXB0aW9uRm9ybWF0dGVyKSB7XG4gICAgICB0aGlzLm1vbnRoQ2FwdGlvbiA9IHRoaXMubW9udGhDYXB0aW9uRm9ybWF0dGVyKGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1vbnRoQ2FwdGlvbiA9IHRoaXMuZGVmYXVsdE1vbnRoQ2FwdGlvbkZvcm1hdHRlcihkYXRlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaGVzIHRoZSBkYXkgb2Ygd2VlayBjYXB0aW9ucy5cbiAgICovXG4gIHByaXZhdGUgcmVmcmVzaERheU9mV2Vla0NhcHRpb25zKCk6IHZvaWQge1xuICAgIGNvbnN0IGRheUNhcHRpb25zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgY29uc3QgZGF5T2ZXZWVrRm9ybWF0dGVyID0gdGhpcy5kYXlPZldlZWtDYXB0aW9uRm9ybWF0dGVyID9cbiAgICAgIHRoaXMuZGF5T2ZXZWVrQ2FwdGlvbkZvcm1hdHRlciA6XG4gICAgICB0aGlzLmRlZmF1bHREYXlPZldlZWtDYXB0aW9uRm9ybWF0dGVyO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBEQVlfTkFNRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRheUNhcHRpb25zLnB1c2goZGF5T2ZXZWVrRm9ybWF0dGVyKGkpKTtcbiAgICB9XG5cbiAgICB0aGlzLmRheXNPZldlZWtDYXB0aW9ucyA9IGRheUNhcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2hlcyB0aGUgY2FsZW5kYXIgdmlldy5cbiAgICogQHBhcmFtIGRhdGUgRGF0ZS5cbiAgICovXG4gIHByaXZhdGUgcmVmcmVzaFZpZXcoZGF0ZTogRGF0ZSk6IHZvaWQge1xuICAgIHRoaXMudmlldyA9IG5ldyBNb250aFZpZXcoZGF0ZSkuY3JlYXRlVmlldyhmYWxzZSwgdGhpcy5maXJzdERheU9mV2Vlayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgQ1NTIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIG1vbnRoLlxuICAgKi9cbiAgZ2V0Q2xhc3NGb3JNb250aCgpOiBzdHJpbmcge1xuICAgIGxldCBjbGFzc2VzVG9BcHBseSA9IHRoaXMubW9udGhDbGFzcztcblxuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICBjbGFzc2VzVG9BcHBseSA9IHRoaXMubW9udGhDbGFzcyArICcgJyArIHRoaXMuZGlzYWJsZWRDbGFzcztcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3Nlc1RvQXBwbHk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgQ1NTIGNsYXNzIGFwcGxpY2FibGUgdG9cbiAgICogdGhlIHNwZWNpZmllZCBkYXkuXG4gICAqIEBwYXJhbSBkYXkgRGF5LlxuICAgKi9cbiAgZ2V0Q2xhc3NGb3JEYXkoZGF5PzogRGF5SW5mbyk6IHN0cmluZyB7XG4gICAgbGV0IGRheUNsYXNzVG9BcHBseSA9ICcnO1xuXG4gICAgaWYgKGRheSkge1xuXG4gICAgICBpZiAoZGF5LmRheSA9PT0gdGhpcy52YWx1ZS5nZXREYXRlKCkpIHtcbiAgICAgICAgZGF5Q2xhc3NUb0FwcGx5ID0gdGhpcy5zZWxlY3RlZERheUNsYXNzO1xuICAgICAgfSBlbHNlIGlmIChkYXkuaXNUb2RheSkge1xuICAgICAgICBkYXlDbGFzc1RvQXBwbHkgPSB0aGlzLmN1cnJlbnREYXlDbGFzcztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXN0b21EYXlDbGFzcykge1xuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodGhpcy52YWx1ZS52YWx1ZU9mKCkpO1xuICAgICAgICBkYXRlLnNldERhdGUoZGF5LmRheSk7XG4gICAgICAgIGRheUNsYXNzVG9BcHBseSA9IHRoaXMuY3VzdG9tRGF5Q2xhc3MoZGF5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgZGF5Q2xhc3NUb0FwcGx5ID0gZGF5Q2xhc3NUb0FwcGx5ICsgJyAnICsgdGhpcy5kaXNhYmxlZERheUNsYXNzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5kYXlDYXB0aW9uQ2xhc3MgKyAnICcgKyBkYXlDbGFzc1RvQXBwbHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRheUNhcHRpb25DbGFzcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGZvcm1hdHRlZCBzdHJpbmcgY29ycmVzcG9uZGluZ1xuICAgKiB0byB0aGUgc3BlY2lmaWVkIGRheS5cbiAgICogQHBhcmFtIGRheSBEYXkgdG8gZm9ybWF0LlxuICAgKi9cbiAgZ2V0Rm9ybWF0dGVkRGF5KGRheTogRGF5SW5mbyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuZGF5Rm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXlGb3JtYXR0ZXIoZGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdERheUZvcm1hdHRlcihkYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyB0aGUgY2xpY2sgZXZlbnQgb2YgYSBkYXkgY2VsbC5cbiAgICogQHBhcmFtIGRheUluZm8gSW5mbyBhYm91dCB0aGUgc2VsZWN0ZWQgZGF5LlxuICAgKi9cbiAgb25EYXlDbGljayhkYXlJbmZvOiBEYXlJbmZvKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIGRheUluZm8pIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkRGF0ZSA9IG5ldyBEYXRlKHRoaXMudmFsdWUudmFsdWVPZigpKTtcbiAgICAgIHNlbGVjdGVkRGF0ZS5zZXREYXRlKGRheUluZm8uZGF5KTtcblxuICAgICAgdGhpcy52YWx1ZSA9IG5ldyBEYXRlKHNlbGVjdGVkRGF0ZS52YWx1ZU9mKCkpO1xuXG4gICAgICB0aGlzLmNoYW5nZS5lbWl0KHNlbGVjdGVkRGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIHRoZSBjbGljayBldmVudCBvZiB0aGUgbW9udGguXG4gICAqL1xuICBvbk1vbnRoQ2xpY2soKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLm1vbnRoQ2xpY2suZW1pdCh0aGlzKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogUmVwcmVzZW50cyBpbmZvcm1hdGlvbiBhYm91dCBvbmVcbiAqIGRheSBvZiB0aGUgbW9udGguXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXlJbmZvIHtcbiAgICBpc1RvZGF5OiBib29sZWFuO1xuICAgIGlzU2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgZGF5OiBudW1iZXI7XG4gICAgZGF0ZTogRGF0ZTtcbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5pbXBvcnQgeyBNb250aENhbGVuZGFyQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL21vbnRoLWNhbGVuZGFyL21vbnRoLWNhbGVuZGFyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNb250aENhcHRpb25UZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlcy9tb250aC1jYXB0aW9uLXRlbXBsYXRlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBEYXlPZldlZWtDYXB0aW9uVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvZGF5LW9mLXdlZWstY2FwdGlvbi10ZW1wbGF0ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgRGF5VGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvZGF5LXRlbXBsYXRlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIEJyb3dzZXJNb2R1bGUsXG4gICAgRm9ybXNNb2R1bGVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgTW9udGhDYWxlbmRhckNvbXBvbmVudCxcbiAgICBNb250aENhcHRpb25UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBEYXlPZldlZWtDYXB0aW9uVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRGF5VGVtcGxhdGVEaXJlY3RpdmVcbiAgXSxcbiAgZXhwb3J0czogW1xuICAgIE1vbnRoQ2FsZW5kYXJDb21wb25lbnQsXG4gICAgTW9udGhDYXB0aW9uVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgRGF5T2ZXZWVrQ2FwdGlvblRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIERheVRlbXBsYXRlRGlyZWN0aXZlXG4gIF1cbn0pXG5leHBvcnQg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